# MASTER SCRIPT

######### COLLABORATIVE EXTENSION FUNCTIONS AND VARIABLES #########
add_frame("partnerFrame",p[0.55,-0.41,0,0,0,3.1416],"base") #real distance is 70 


tWait = 0.0005

def movel_partner(pose, a=1.2, v=0.25, t=0, r=0):

  # Wait for follower to be idle (stage 0)
  #popup("function called", "status")
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end

  # Send parameters
  write_target(pose)
  write_output_float_register(30, a)
  write_output_float_register(31, v)
  write_output_float_register(32, t)
  write_output_float_register(33, r)

  # Send command code (stage 1)
  write_output_integer_register(25, 10)

  # Wait for follower to ACK (stage 2)
  while (read_input_integer_register(25) != 2):
    sleep(tWait)
  end

  # Wait for follower to finish and signal DONE (stage 3)
  while (read_input_integer_register(25) != 3):
    sleep(tWait)
  end

  # Reset master command register (stage 4)
  write_output_integer_register(25, 0)

  # Wait for follower to return to idle
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end
end

def movej_partner(q, a=1.3, v=0.26, t=0, r=0):

  #popup("function called", "status")
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end

  #popup("partner is idle", "status")

  write_output_integer_register(25, 11)
  write_target(q)
  write_output_float_register(30, a)
  write_output_float_register(31, v)
  write_output_float_register(32, t)
  write_output_float_register(33, r)
  # Wait for follower to ACK (stage 2)
  while (read_input_integer_register(25) != 2):
    sleep(tWait)
  end

  #popup("command received by partner", "status")

  # Wait for follower to finish and signal DONE (stage 3)
  while (read_input_integer_register(25) != 3):
    sleep(tWait)
  end

  #popup("partner action done", "status")

  # Reset master command register (stage 4)
  write_output_integer_register(25, 0)

  # Wait for follower to return to idle
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end

  #popup("partner idle", "status")

end

def servoj_partner(q, a=0, v=0, t=0.002, lookahead_time=0.1, gain=300):
  write_output_integer_register(25, 12)
  write_target(q)
  write_output_float_register(30, a)
  write_output_float_register(31, v)
  write_output_float_register(32, t)
  write_output_float_register(33, lookahead_time)
  write_output_float_register(34, gain)
end

def servoj_to_pose_partner(pose, a=0, v=0, t=0.002, lookahead_time=0.1, gain=300):
  write_output_integer_register(25, 20)
  nextPosePartner = convert_pose(pose, "base", "partnerFrame")
  write_target(nextPosePartner)
  write_output_float_register(30, a)
  write_output_float_register(31, v)
  write_output_float_register(32, t)
  write_output_float_register(33, lookahead_time)
  write_output_float_register(34, gain)
end

def get_actual_tcp_pose_partner():
  x = read_input_float_register(38)
  y = read_input_float_register(39)
  z = read_input_float_register(40)
  rx = read_input_float_register(41)
  ry = read_input_float_register(42)
  rz = read_input_float_register(43)
  posePartnerFrame = p[x,y,z,rx,ry,rz]
  # popup(posePartnerFrame, "pose Partner on partner base")

  pose = convert_pose(posePartnerFrame, "partnerFrame", "base")
  return pose
end 

def movej_to_pose_partner(pose, a=1.3, v=0.26, t=0, r=0):

  #popup("function called", "status")
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end

  #popup("partner is idle", "status")

  write_output_integer_register(25, 22)
  write_target(pose)
  write_output_float_register(30, a)
  write_output_float_register(31, v)
  write_output_float_register(32, t)
  write_output_float_register(33, r)
  # Wait for follower to ACK (stage 2)
  while (read_input_integer_register(25) != 2):
    sleep(tWait)
  end

  #popup("command received by partner", "status")

  # Wait for follower to finish and signal DONE (stage 3)
  while (read_input_integer_register(25) != 3):
    sleep(tWait)
  end

  #popup("partner action done", "status")

  # Reset master command register (stage 4)
  write_output_integer_register(25, 0)

  # Wait for follower to return to idle
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end

  #popup("partner idle", "status")

end

# def set_frame_partner(pose = [0,0,0,0,0,0]):

#   # Wait for follower to be idle (stage 0)
#   #popup("function called", "status")
#   while (read_input_integer_register(25) != 0):
#     sleep(tWait)
#   end

#   # Send parameters
#   write_target(pose)

#   # Send command code (stage 1)
#   write_output_integer_register(25, 21)

#   # Wait for follower to ACK (stage 2)
#   while (read_input_integer_register(25) != 2):
#     sleep(tWait)
#   end

#   # Wait for follower to finish and signal DONE (stage 3)
#   while (read_input_integer_register(25) != 3):
#     sleep(tWait)
#   end

#   # Reset master command register (stage 4)
#   write_output_integer_register(25, 0)

#   # Wait for follower to return to idle
#   while (read_input_integer_register(25) != 0):
#     sleep(tWait)
#   end

# end

def move_frame_partner(pose = [0,0,0,0,0,0], frame = 2 ):

  # Wait for follower to be idle (stage 0)
  #popup("function called", "status")
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end

  # Send parameters
  write_target(pose)
  write_output_integer_register(30, frame)


  # Send command code (stage 1)
  write_output_integer_register(25, 22)

  # Wait for follower to ACK (stage 2)
  while (read_input_integer_register(25) != 2):
    sleep(tWait)
  end

  # Wait for follower to finish and signal DONE (stage 3)
  while (read_input_integer_register(25) != 3):
    sleep(tWait)
  end

  # Reset master command register (stage 4)
  write_output_integer_register(25, 0)

  # Wait for follower to return to idle
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end

end

def write_target(target):
  write_output_float_register(24, target[0])
  write_output_float_register(25, target[1])
  write_output_float_register(26, target[2])
  write_output_float_register(27, target[3])
  write_output_float_register(28, target[4])
  write_output_float_register(29, target[5])
end


def set_configurable_digital_out_partner(n, l):
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end

  write_output_integer_register(27, n) # Select IO number
  write_output_boolean_register(64, l)
  write_output_integer_register(25, 13)

  # Wait for follower to ACK (stage 2)
  while (read_input_integer_register(25) != 2):
    sleep(tWait)
  end

  # Wait for follower to finish and signal DONE (stage 3)
  while (read_input_integer_register(25) != 3):
    sleep(tWait)
  end

  # Reset master command register (stage 4)
  write_output_integer_register(25, 0)

  # Wait for follower to return to idle
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end
end

def set_standard_digital_out_partner(n, l): 
  # function accepts n range of [0:7] and l level True/False
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end
  write_output_integer_register(27, n) # Select IO number
  write_output_boolean_register(64, l)
  write_output_integer_register(25, 14) #send command code

  # Wait for follower to ACK (stage 2)
  while (read_input_integer_register(25) != 2):
    sleep(tWait)
  end
  # Wait for follower to finish and signal DONE (stage 3)
  while (read_input_integer_register(25) != 3):
    sleep(tWait)
  end
  # Reset master command register (stage 4)
  write_output_integer_register(25, 0)

  # Wait for follower to return to idle
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end
end

def set_standard_analog_out_partner(n,f):
  # function accepts n range of [0:1] and f equals the relative signal level between 0 and 1
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end
  
  write_output_integer_register(27, n) # Select IO number
  write_output_float_register(35, f) 
  write_output_integer_register(25, 15) #send command code
  
  # Wait for follower to ACK (stage 2)
  while (read_input_integer_register(25) != 2):
    sleep(tWait)
  end

  # Wait for follower to finish and signal DONE (stage 3)
  while (read_input_integer_register(25) != 3):
    sleep(tWait)
  end

  # Reset master command register (stage 4)
  write_output_integer_register(25, 0)

  # Wait for follower to return to idle
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end
end

def set_tool_digital_out_partner(n, l):
  # function accepts n range of [0:1] and l level True/False
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end
  
  write_output_integer_register(27, n) # Select IO number
  write_output_boolean_register(64, l)
  write_output_integer_register(25, 16)

  # Wait for follower to ACK (stage 2)
  while (read_input_integer_register(25) != 2):
    sleep(tWait)
  end

  # Wait for follower to finish and signal DONE (stage 3)
  while (read_input_integer_register(25) != 3):
    sleep(tWait)
  end

  # Reset master command register (stage 4)
  write_output_integer_register(25, 0)

  # Wait for follower to return to idle
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end
end

def get_configurable_digital_in_partner(n):
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end

  write_output_integer_register(28, n) # Select IO number to read from
  write_output_integer_register(25, 17)

  # Wait for follower to ACK (stage 2)
  while (read_input_integer_register(25) != 2):
    sleep(tWait)
  end

  # Wait for follower to finish and signal DONE (stage 3)
  while (read_input_integer_register(25) != 3):
    sleep(tWait)
  end

  read_value1 = read_input_boolean_register(65) #read boolean value
  # Reset master command register (stage 4)
  write_output_integer_register(25, 0)

  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end
  return read_value1
end

def get_standard_analog_in_partner(n):
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end

  write_output_integer_register(25, 18)
  write_output_integer_register(28, n) # Select IO number

  # Wait for follower to ACK (stage 2)
  while (read_input_integer_register(25) != 2):
    sleep(tWait)
  end

  # Wait for follower to finish and signal DONE (stage 3)
  while (read_input_integer_register(25) != 3):
    sleep(tWait)
  end

  read_value2 = read_input_float_register(37)
  write_output_integer_register(25, 0)

  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end

  return read_value2
end

def get_standard_digital_in_partner(n):
  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end
  write_output_integer_register(25, 19)
  write_output_integer_register(28, n) # Select IO number
  
  # Wait for follower to ACK (stage 2)
  while (read_input_integer_register(25) != 2):
    sleep(tWait)
  end

  # Wait for follower to finish and signal DONE (stage 3)
  while (read_input_integer_register(25) != 3):
    sleep(tWait)
  end

  read_value3 = read_input_boolean_register(66) #boolean value
  write_output_integer_register(25, 0)

  while (read_input_integer_register(25) != 0):
    sleep(tWait)
  end

  return read_value3
end


######### USER PROGRAM FUNCTIONS AND VARIABLES #########

def partnerThread():
  while(True):
    poseMaster = get_actual_tcp_pose()
    # posePartner = get_actual_tcp_pose_partner()
    # nextPosPartner = p[poseMaster[0],poseMaster[1],poseMaster[2],posePartner[3],posePartner[4],posePartner[5]]
    rotation180Z = p[0, 0, 0, 0, 3.1416, 0]
    nextPosPartner = pose_trans(poseMaster, rotation180Z)
    servoj_to_pose_partner(nextPosPartner,0,0, 0.002,0.1, gain=2000)
  end
 end

######### INITAL SYNC #########
write_output_integer_register(25, 0)

######### BEFORE PROGRAM #########

#Initialization of Variables
# global firstPoseMaster = p[0.2956, -0.1151, 0.4632, d2r(-69.14), d2r(69.37), d2r(-69.14)]
# global secondPoseMaster = p[0.3764, -0.1151, 0.368, d2r(-69.14), d2r(69.37), d2r(-69.14)]
# global firstPosePartner = p[0.2956, -0.1151, 0.4632, d2r(-69.14), d2r(-69.37), d2r(69.14)]
# global secondPosePartner = p[0.3764, -0.1151, 0.368, d2r(-69.14), d2r(-69.37), d2r(69.14)]
# movej(initPoseMaster, a=1.3962634015954636, v=1.0471975511965976)
#movej_partner(syncPos, a=1.3962634015954636, v=1.0471975511965976)


# while (True):

poseMaster = get_actual_tcp_pose()
# nextPosPartner = p[poseMaster[0],poseMaster[1],poseMaster[2],posePartner[3],posePartner[4],posePartner[5]]
rotation180Z = p[0, 0, 0, 0, 3.1416, 0]
nextPosPartner = pose_trans(poseMaster, rotation180Z)
movej_to_pose_partner(nextPosPartner, a=1.3, v=0.26, t=0, r=0)

# printNextPosPartner = [nextPosPartner[0],nextPosPartner[1],nextPosPartner[2],r2d(nextPosPartner[3]),r2d(nextPosPartner[4]),r2d(nextPosPartner[5])]
# request_boolean_from_primary_client(printNextPosPartner)

freedrive_mode([1,1,1,1,1,1])

thread move_partnerThread(): partnerThread() end
thrd = run move_partnerThread()
request_boolean_from_primary_client("end program")

kill thrd



# movel(secondPoseMaster, a=1.2, v=0.25, t=0, r=0)
# pose_partner = get_actual_tcp_pose_partner()

# movel_partner(firstPosePartner, a=1.2, v=0.25, t=0, r=0)
# movel_partner(secondPosePartner, a=1.2, v=0.25, t=0, r=0)
# movej(thirdPoseMaster, a=1.2, v=0.25, t=0, r=0)


  # poseMaster = get_actual_tcp_pose()
  # posePartner = get_actual_tcp_pose_partner()
  # # # popup(poseMaster, "pose Master")
  # # popup(posePartner, "pose Partner on master base", True)



  # # sleep(10)
  # poseMaster[0] = poseMaster[0] + 0.05
  # posePartner[0] = posePartner[0] + 0.05
  # # popup(poseMaster, "pose Master")
  # # # popup(posePartner, "pose Partner")

  # movel(poseMaster, a=1.2, v=0.25, t=0, r=0)
  # movel_partner(posePartner, a=1.2, v=0.25, t=0, r=0)


# end

