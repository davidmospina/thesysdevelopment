# PARTNER SCRIPT

#Initialization of Variables
reset_world_model()

global moveTarget = [0, 0, 0, 0, 0, 0]
add_frame("masterFrame",p[0.679,-0.397,0.003,0,0,3.1416],"base")
add_frame("tcpMaster",p[0,0,0,0,0,0],"base")

tWait = 0.0005

def read_target():
    tmpMoveTarget=[0,0,0,0,0,0]
    tmpMoveTarget[0] = read_input_float_register(24)
    tmpMoveTarget[1] = read_input_float_register(25)
    tmpMoveTarget[2] = read_input_float_register(26)
    tmpMoveTarget[3] = read_input_float_register(27)
    tmpMoveTarget[4] = read_input_float_register(28)
    tmpMoveTarget[5] = read_input_float_register(29)
    global moveTarget=tmpMoveTarget
end

######### NOT NATIVE URSCRIPT FUNCTIONS #########


def external_speed_control(a,t):

  speed_threshold = 1e-4  # deadzone to ignore tiny input noise
  speed_control_active = True
  while speed_control_active:
      # Read linear velocities (vx, vy, vz)
      vx = read_input_float_register(38)
      vy = read_input_float_register(39)
      vz = read_input_float_register(40)

      # Read angular velocities (rx, ry, rz)
      rx = read_input_float_register(41)
      ry = read_input_float_register(42)
      rz = read_input_float_register(43)

      # Build the velocity vector
      speed_vector = [vx, vy, vz, rx, ry, rz]

      # Check if velocity vector is "significant"
      speed_mag = norm(speed_vector)

      if speed_mag > speed_threshold:
          speedl(struct(vel=speed_vector, frame="masterFrame") , a=a, t=t)
      else:
          speedl([0, 0, 0, 0, 0, 0], a=a, t=t)
      end
      leave = read_input_integer_register(30)
      if leave == 1:
        speed_control_active = False
      end
  end
end

def virtual_tcp_control():
  timestep = 0.002
  lookahead_time = 0.1
  gain = 500
  deadzone = 1e-4

  tcp_control_active = True
  virtual_tcp = get_actual_tcp_pose()

  while tcp_control_active:
      # Read controller inputs
      vx = read_input_float_register(38)
      vy = read_input_float_register(39)
      vz = read_input_float_register(40)
      rx = read_input_float_register(41)
      ry = read_input_float_register(42)
      rz = read_input_float_register(43)

      speed_vector = [vx, vy, vz, rx, ry, rz]
      speed_mag = norm(speed_vector)

      if speed_mag > deadzone:
        #Apply delta to virtual TCP pose
        delta_pose = p[vx * timestep, vy * timestep, vz * timestep, rx * timestep, ry * timestep, rz * timestep]
        virtual_tcp = pose_trans(virtual_tcp, delta_pose)

        # Calculate joint target and send servoj
        q_target = get_inverse_kin(virtual_tcp)
        servoj(q_target, t=timestep, lookahead_time=lookahead_time, gain=gain)
      else:
          # Hold current position
          servoj(get_actual_joint_positions(), t=timestep, lookahead_time=lookahead_time, gain=gain)
      end

      # Exit condition (same as external_speed_control)
      leave = read_input_integer_register(30)
      if leave == 1:
          tcp_control_active = False
      end
  end
end

######### ADMITTANCE CONTROL #########




###
# Helper function to make a diagnol matrix
# @param values array input list or pose
# @returns matrix diagnol matrix
###
def adm_diag_6_6(values):
  return [[values[0], 0, 0, 0, 0, 0], [0, values[1], 0, 0, 0, 0], [0, 0, values[2], 0, 0, 0], [0, 0, 0, values[3], 0, 0], [0, 0, 0, 0, values[4], 0], [0, 0, 0, 0, 0, values[5]]]
end


###
# Helper function to extract the position part from a pose
# @param p_in pose input pose
# @returns array position from pose
###
def adm_get_pos_from_pose(p_in):
  return [p_in[0], p_in[1], p_in[2]]
end

###
# Helper function to extract the rotation part from a pose
# @param p_in pose input pose
# @returns array rotation from pose
###
def adm_get_rot_from_pose(p_in):
  return [p_in[3], p_in[4], p_in[5]]
end

###
# Get the measured wrench at the tool flange
# @returns array wrench at the tool flange
###
def adm_get_flange_wrench():
  local ft = get_tcp_force() #Tcp force returns the force and torques at the tool flange with base orientation
  local t_end_base = pose_trans(get_target_tcp_pose(), pose_inv(get_tcp_offset()))
  local current_rot_in_tool = pose_inv(p[0, 0, 0, t_end_base[3], t_end_base[4], t_end_base[5]])
  local f = pose_trans(current_rot_in_tool, p[ft[0], ft[1], ft[2], 0, 0, 0])
  local t = pose_trans(current_rot_in_tool, p[ft[3], ft[4], ft[5], 0, 0, 0])
  return [f[0], f[1], f[2], t[0], t[1], t[2]]
end

###
# Apply a dead band for force and torques. For make the robot stand still when not driven external forces
# @param wrench_in array input wrench that might be zeroed
# @param bandwidth_force number force bandwith
# @param bandwidth_torque number torque bandwith
# @returns array wrench that might be zeroed
###
def adm_apply_dead_band(wrench_in, bandwidth_force, bandwidth_torque):
  local F = adm_get_pos_from_pose(wrench_in)
  local F_norm = norm(F)
  local T = adm_get_rot_from_pose(wrench_in)
  local T_norm = norm(T)

  if ((F_norm < bandwidth_force) and (T_norm < bandwidth_torque)):
    wrench_in = wrench_in * 0
  end

  return wrench_in
end

###
# Get a smooth dead band scale. For use in the appplying dead band functions
# @param value number input value
# @param deadBand number deadBand
# @param smoothBand number smoothBand
# @returns number scale in the range from 0-1
###
def adm_smooth_dead_single_dim_scale(value, deadBand, smoothBand):
  local normVal = norm(value)
  if normVal <= deadBand:
    #In deadband
    return 0
    
  elif normVal > (deadBand + smoothBand):
    #Pass deadband
    return ((normVal - deadBand - smoothBand * 0.5) / normVal)
  end

  #Smooth trancision
  local s = normVal - deadBand
  return (0.5 * s * s / smoothBand) / normVal
end

### TEST_START 
# # Test function for continuity in adm_smooth_dead_single_dim_scale
# def adm_test_smooth_dead_band():
#   def test_smooth_config(dead_band, smooth_band):
#     #zero in-out test
#     assert(adm_smooth_dead_single_dim_scale(0, dead_band, smooth_band) == 0)

#     #continuity test
#     def continuity(dead_band, smooth_band):
#       local x = 0
#       local dx = 0.1
#       local y = 0
#       while x < (dead_band + smooth_band + 50):
#         local dy = norm(adm_smooth_dead_single_dim_scale(x, dead_band, smooth_band) - y)
#         #Test that the change in y does not gets higher than the change in x
#         assert(dy <= dx)
#         x = x + dx
#         y = y + dy
#       end
#     end
#     continuity(dead_band, smooth_band)

#   end
#   test_smooth_config(1, 2)
#   test_smooth_config(10, 20)
#   test_smooth_config(0, 20)
#   test_smooth_config(20, 0)

# end
# adm_test_smooth_dead_band() #run test
### TEST_STOP

###
# Apply a smooth dead band to make to robot stand still when not driven external forces
# @param wrench_in array wrench_in that will be scaled
# @param bandwidth_force number force bandwidth
# @param bandwidth_torque number torque bandwidth
# @param smooth_force number force smooth
# @param smooth_torque number torque smooth
# @returns array wrench where the smooth dead band is applied
###
def adm_apply_dead_band_smooth(wrench_in, bandwidth_force, bandwidth_torque, smooth_force, smooth_torque):
  local wrench_gain = [adm_smooth_dead_single_dim_scale(wrench_in[0], bandwidth_force, smooth_force), adm_smooth_dead_single_dim_scale(wrench_in[1], bandwidth_force, smooth_force), adm_smooth_dead_single_dim_scale(wrench_in[2], bandwidth_force, smooth_force), adm_smooth_dead_single_dim_scale(wrench_in[3], bandwidth_torque, smooth_torque), adm_smooth_dead_single_dim_scale(wrench_in[4], bandwidth_torque, smooth_torque), adm_smooth_dead_single_dim_scale(wrench_in[5], bandwidth_torque, smooth_torque)]
  return wrench_gain * wrench_in
end

###
# Transform a velocity vector
# @param t pose transformation from the input velocity to the output velocity
# @param v array inout velocity vector
# @returns array tranformed output velocity vector
###
def adm_vel_trans(t, v):
  local vw = wrench_trans(t, [v[3], v[4], v[5], v[0], v[1], v[2]])
  return [vw[3], vw[4], vw[5], vw[0], vw[1], vw[2]]
end

###
# rotates a velocity into new reference frame
# @param frame pose current velocity reference frame
# @param velocity array input velocity vector
# @returns array velocity with new reference frame
###
def adm_rotate_velocity_in_frame(frame, velocity):
  local p_tcp = p[0, 0, 0, frame[3], frame[4], frame[5]]

  local velocity_pos_p = p[velocity[0], velocity[1], velocity[2], 0, 0, 0]
  local velocity_rot_p = p[velocity[3], velocity[4], velocity[5], 0, 0, 0]

  local trans = pose_trans(p_tcp, velocity_pos_p)
  local rot = pose_trans(p_tcp, velocity_rot_p)

  return [trans[0], trans[1], trans[2], rot[0], rot[1], rot[2]]
end

###
# rotates a wrench into new reference frame
# @param frame pose current wrench reference frame
# @param wrench array input wrench vector
# @returns array wrench with new reference frame
###
def adm_rotate_wrench_in_frame(frame, wrench):
  return adm_rotate_velocity_in_frame(frame, wrench)
end

# Please note that parameters needs to be tuned for each use case and robot model.
# The default parameters is tune for a light behavior on a UR5e without payload.
# Watch out for singular positions!
###
# summary
# @param mass_scaling number scale of mases
# @param damping_scaling number scale of the damping
# @param mass_list array list of masses for the 6 DoF
# @param damping_list array list of damping for the 6 DoF
# @param base_to_compliance_frame pose compliance frame
# @param tool_flange_to_compliance_center pose transformation from tool flange to center of compliance
# @param dead_band array list of the deadband [Force dead band,   Torque dead band,  Force smooth band, Torque smooth band]
# @param compliance_vector array A 6d vector of 0s and 1s. 1 means that the robot will apply admittance  in the corresponding axis of the compliance frame.
# @param stiffness_params array list of stiffness for the 6 DoF
# @param target_wrench array the target wrench the robot shall apply
###
def admittance_control(mass_scaling = 0.5, damping_scaling = 0.5, mass_list = [22.5, 22.5, 22.5, 1, 1, 1], damping_list = [25, 25, 25, 2, 2, 2], base_to_compliance_frame = p[0, 0, 0, 0, 0, 0], tool_flange_to_compliance_center = p[0, 0, 0, 0, 0, 0], dead_band = [2, 0.15, 2, 0.15], compliance_vector = [1, 1, 1, 1, 1, 1], stiffness_params = [0, 0, 0, 0, 0, 0], target_wrench = [0, 0, 0, 0, 0, 0]):

  ##  Admittance control parameters ##
  local M = adm_diag_6_6(mass_list) #Mass
  local M = M * mass_scaling
  local D = adm_diag_6_6(damping_list) # Damping
  local D = D * damping_scaling
  local K = adm_diag_6_6(stiffness_params) # Stiffness

  ## Initialize Error terms ##
  local vel_target = [0, 0, 0, 0, 0, 0]
  local x_e = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0] # pos error term
  local dx_e = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0] # vel error term
  local ddx_e = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0] # acc error term
  local last_ddx_e = ddx_e
  local last_dx_e = dx_e
  local last_x_e = x_e

  ## Zero F/T sensor before starting ##
  zero_ftsensor()

  ## Admittance control loop ##
  while True:
    #Dead band to make to robot stand still when not driven external forces
    local wrench_at_tool = adm_apply_dead_band_smooth(adm_get_flange_wrench(), dead_band[0], dead_band[1], dead_band[2], dead_band[3])

    # Make it possible to define the compliance center relative to the tool flange by "tool_flange_to_compliance_center" argument
    local wrench_at_compliance_center = wrench_trans(tool_flange_to_compliance_center, wrench_at_tool)

    # Rotate the wrench to align with the compliance frame give by "base_to_compliance_frame" argument
    local T_compliance_center_to_tcp = pose_trans(pose_inv(tool_flange_to_compliance_center), get_tcp_offset())
    local T_compliance_center_to_base = pose_trans(T_compliance_center_to_tcp, pose_inv(get_target_tcp_pose()))
    local T_compliance_frame_to_compliance_center = pose_inv(pose_trans(T_compliance_center_to_base, base_to_compliance_frame))
    local force_torque_error = adm_rotate_wrench_in_frame(T_compliance_frame_to_compliance_center, wrench_at_compliance_center)

    # Apply compliance selection in "base_to_compliance_frame"
    force_torque_error = force_torque_error * compliance_vector

    # Do the admittance integration
    ddx_e = inv(M) * ((force_torque_error - target_wrench) - (K * x_e) - (D * dx_e))
    dx_e = (get_steptime() * 0.5) * (ddx_e + last_ddx_e) + last_dx_e
    x_e = (get_steptime() * 0.5) * (dx_e + last_dx_e) + last_x_e

    last_ddx_e = ddx_e
    last_dx_e = dx_e
    last_x_e = x_e

    # Rotate back from the compliance frame to the compliance tool center frame
    local vel_target_flange = adm_rotate_wrench_in_frame(pose_inv(T_compliance_frame_to_compliance_center), dx_e)

    # Transform the velocity to be based at TCP
    local vel_target_tcp = adm_vel_trans(pose_inv(T_compliance_center_to_tcp), vel_target_flange)

    # Rotation the velocity to be based at TCP with base orientation to fit the format for speedl
    local vel_target_base_tcp = adm_rotate_velocity_in_frame(get_target_tcp_pose(), vel_target_tcp)

    #Make the robot move
    speedl(vel_target_base_tcp, a = 5, t = get_steptime(), aRot = 45)
  end
end




######### INITAL SYNC #########
write_output_integer_register(25, 0)

######### MAIN PROGRAM #########
while (True):
  startTime = time(mode = 2)
  while(True):
    functionCode = read_input_integer_register(25)
    if functionCode != 12 and functionCode != 20 :

      #movel
      if functionCode == 10:
        # Acknowledge command received (stage 2)
        write_output_integer_register(25, 2)

        # Read parameters
        a = read_input_float_register(30)
        v = read_input_float_register(31)
        t = read_input_float_register(32)
        r = read_input_float_register(33)
        read_target()

        # Execute movel (stage 3)
        movel(struct(pose = p[moveTarget[0], moveTarget[1], moveTarget[2], moveTarget[3], moveTarget[4], moveTarget[5]], frame = "masterFrame"), a, v, t, r)

        # Signal done
        write_output_integer_register(25, 3)

        # Wait for master to reset to 0
        while (read_input_integer_register(25) != 0):
          sleep(tWait)
        end

        # Reset self to idle (stage 0)
        write_output_integer_register(25, 0)

      #movej
      elif functionCode == 11:
        #Acknowledge command received (stage 2)
        write_output_integer_register(25, 2)
        a = read_input_float_register(30)
        v = read_input_float_register(31)
        t = read_input_float_register(32)
        r = read_input_float_register(33)
        read_target()
        movej(moveTarget,a,v,t,r)

        # Signal done
        write_output_integer_register(25, 3)
        # Wait for master to reset to 0
        while (read_input_integer_register(25) != 0):
          sleep(tWait)
        end
        write_output_integer_register(25, 0)

      # #add_collab_frame
      # elif (functionCode == 21):
      #   #Acknowledge command received (stage 2)
      #   write_output_integer_register(25, 2)
      #   read_target()
      #   add_frame("frameA",p[moveTarget[0], moveTarget[1], moveTarget[2], moveTarget[3], moveTarget[4], moveTarget[5]],"base")
      #   sleep(0.004)
      #   # Signal done
      #   write_output_integer_register(25, 3)
      #   # Wait for master to reset to 0
      #   while (read_input_integer_register(25) != 0):
      #     sleep(tWait)
      #   end
      #   write_output_integer_register(25, 0)

      #move_collab_frame
      elif (functionCode == 21):
        #Acknowledge command received (stage 2)
        write_output_integer_register(25, 2)
        read_target()
        frame = read_input_integer_register(30)
        if frame == 1:
          move_frame("masterFrame",p[moveTarget[0], moveTarget[1], moveTarget[2], moveTarget[3], moveTarget[4], moveTarget[5]],"base")
        elif frame == 2:
          move_frame("tcpMaster",p[moveTarget[0], moveTarget[1], moveTarget[2], moveTarget[3], moveTarget[4], moveTarget[5]],"masterFrame")
        end
        sleep(0.004)
        # Signal done
        write_output_integer_register(25, 3)
        # Wait for master to reset to 0
        while (read_input_integer_register(25) != 0):
          sleep(tWait)
        end
        write_output_integer_register(25, 0)


      elif functionCode == 13:
        # Acknowledge command received (stage 2)
        write_output_integer_register(25, 2)

        n = read_input_integer_register(27) #The number (id) of the output
        l = read_input_boolean_register(64) #signal level
        set_configurable_digital_out(n, l)
        sleep(0.004)

        # Signal done
        write_output_integer_register(25, 3)
        # Wait for master to reset to 0
        while (read_input_integer_register(25) != 0):
          sleep(tWait)
        end
        # Reset self to idle (stage 0)
        write_output_integer_register(25, 0)

      elif functionCode == 14:
        # Acknowledge command received (stage 2)
        write_output_integer_register(25, 2)

        n = read_input_integer_register(27) #The number (id) of the output
        l = read_input_boolean_register(64) #signal level
        set_standard_digital_out(n, l)
        sleep(0.004)

        # Signal done
        write_output_integer_register(25, 3)
        # Wait for master to reset to 0
        while (read_input_integer_register(25) != 0):
          sleep(tWait)
        end
        # Reset self to idle (stage 0)
        write_output_integer_register(25, 0)

      elif functionCode == 15:
        # Acknowledge command received (stage 2)
        write_output_integer_register(25, 2)

        n = read_input_integer_register(27) #The number (id) of the output
        av = read_input_float_register(35) #relative signal level for Analog Out
        set_standard_analog_out(n,av)
        sleep(0.004)

        # Signal done
        write_output_integer_register(25, 3)
        # Wait for master to reset to 0
        while (read_input_integer_register(25) != 0):
          sleep(tWait)
        end
        # Reset self to idle (stage 0)
        write_output_integer_register(25, 0)

      elif functionCode == 16:
        # Acknowledge command received (stage 2)
        write_output_integer_register(25, 2)

        n = read_input_integer_register(27) #The number (id) of the output
        l = read_input_boolean_register(64) #signal level
        set_tool_digital_out(n,l)
        sleep(0.004)

        # Signal done
        write_output_integer_register(25, 3)
        # Wait for master to reset to 0
        while (read_input_integer_register(25) != 0):
          sleep(tWait)
        end
        # Reset self to idle (stage 0)
        write_output_integer_register(25, 0)

      elif functionCode == 17:
        # Acknowledge command received (stage 2)
        write_output_integer_register(25, 2)

        n = read_input_integer_register(28)
        level = get_configurable_digital_in(n) #needs a boolean output register placeholder
        sleep(0.004)
        write_output_boolean_register(65,level)

        # Signal done
        write_output_integer_register(25, 3)
        # Wait for master to reset to 0
        while (read_input_integer_register(25) != 0):
          sleep(tWait)
        end
        # Reset self to idle (stage 0)
        write_output_integer_register(25, 0)

      elif functionCode == 18:
        # Acknowledge command received (stage 2)
        write_output_integer_register(25, 2)

        n = read_input_integer_register(28)
        float = get_standard_analog_in(n) #needs a float output register placeholder
        sleep(0.004)
        write_output_float_register(37,float)

        # Signal done
        write_output_integer_register(25, 3)
        # Wait for master to reset to 0
        while (read_input_integer_register(25) != 0):
          sleep(tWait)
        end
        # Reset self to idle (stage 0)
        write_output_integer_register(25, 0)

      elif functionCode == 19:
        # Acknowledge command received (stage 2)
        write_output_integer_register(25, 2)

        n = read_input_integer_register(28)
        level = get_standard_digital_in(n) #needs a boolean output register placeholder
        sleep(0.004)
        write_output_boolean_register(66,level)

        # Signal done
        write_output_integer_register(25, 3)

        # Wait for master to reset to 0
        while (read_input_integer_register(25) != 0):
          sleep(tWait)
        end
        # Reset self to idle (stage 0)

      #movej_to_pose
      elif functionCode == 22:
        # popup("partner is idle", "status")


        #Acknowledge command received (stage 2)
        write_output_integer_register(25, 2)
        a = read_input_float_register(30)
        v = read_input_float_register(31)
        t = read_input_float_register(32)
        r = read_input_float_register(33)
        read_target()
        movej(struct(pose = p[moveTarget[0], moveTarget[1], moveTarget[2], moveTarget[3], moveTarget[4], moveTarget[5]], frame = "masterFrame"),a,v,t,r)

        # Signal done
        write_output_integer_register(25, 3)
        # Wait for master to reset to 0
        while (read_input_integer_register(25) != 0):
          sleep(tWait)
        end
        write_output_integer_register(25, 0)

      
      #external_speed_control      
      elif functionCode == 23:

        #Acknowledge command received (stage 2)
        write_output_integer_register(25, 2)
        a = read_input_float_register(30)
        t = read_input_float_register(31)
        external_speed_control(a,t)


      #virtual_tcp_control      
      elif functionCode == 24:

        #Acknowledge command received (stage 2)
        write_output_integer_register(25, 2)
        a = read_input_float_register(30)
        t = read_input_float_register(31)
        virtual_tcp_control()

      elif functionCode == 25:
        write_output_integer_register(25, 2)
        admittance_control(
          mass_scaling = 0.6,
          damping_scaling = 0.6,
          mass_list = [11, 11, 11, 0.5, 0.5, 0.5],
          damping_list = [10, 10, 10, 1, 1, 1],
          stiffness_params = [0, 0, 0, 0, 0, 0],
          dead_band = [1.0, 0.025, 4.0, 0.1],
          compliance_vector = [1, 1, 1, 1, 1, 1],
          base_to_compliance_frame = p[0, 0, 0, 0, 0, 0],
          tool_flange_to_compliance_center = p[0, 0, 0.055, 0, 0, 0],
          target_wrench = [0, 0, 0, 0, 0, 0]
        )   
      end
    else:
      #servoJ
      if functionCode == 12:
        a = read_input_float_register(30)
        v = read_input_float_register(31)
        t = read_input_float_register(32)
        lookahead_time = read_input_float_register(33)
        gain = read_input_float_register(34)
        read_target()
        servoj(moveTarget,a,v,t,lookahead_time,gain)
      #servoJ_to_pose:
      elif functionCode == 20:
        a = read_input_float_register(30)
        v = read_input_float_register(31)
        t = read_input_float_register(32)
        lookahead_time = read_input_float_register(33)
        gain = read_input_float_register(34)
        read_target()
        nextPose = convert_pose(p[moveTarget[0], moveTarget[1], moveTarget[2], moveTarget[3], moveTarget[4], moveTarget[5]], "masterFrame", "base")
        q = get_inverse_kin(nextPose)
        servoj(q,a,v,t,lookahead_time,gain)
      end
    end
  end
end